#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <unordered_map>

using namespace std;

const int ALPHABET_COUNT = 256;

vector<int> computePrefix(const string& pattern) {
    int m = pattern.size();
    vector<int> prefix(m, 0);
    int j = 0;
    for (int i = 1; i < m; i++) {
        while (j > 0 && pattern[i] != pattern[j]) {
            j = prefix[j - 1];
        }
        if (pattern[i] == pattern[j]) {
            j++;
        }
        prefix[i] = j;
    }
    return prefix;
}

vector<vector<int>> buildTransitionTable(const string& pattern) {
    int m = pattern.size();
    vector<int> prefix = computePrefix(pattern);
    vector<vector<int>> transition(m + 1, vector<int>(ALPHABET_COUNT, 0));

    for (int state = 0; state <= m; state++) {
        for (int ch = 0; ch < ALPHABET_COUNT; ch++) {
            if (state < m && pattern[state] == (char)ch) {
                transition[state][ch] = state + 1;
            } else {
                if (state == 0) {
                    transition[state][ch] = 0;
                } else {
                    transition[state][ch] = transition[prefix[state - 1]][ch];
                }
            }
        }
    }

    return transition;
}

string findLCSExcluding( string a,string b,string c) {
    int n = a.size(), m = b.size(), f = c.size();
    if (f == 0) return "";

    vector<vector<int>> transition = buildTransitionTable(c);
    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(m + 1, vector<int>(f, 0)));
    vector<vector<vector<pair<int, char>>>> backtrack(n + 1, vector<vector<pair<int, char>>>(m + 1, vector<pair<int, char>>(f, {-1, 'N'})));

    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            for (int k = 0; k < f; k++) {
                int currentValue = dp[i][j][k];

                if (i < n) {
                    if (dp[i + 1][j][k] < currentValue) {
                        dp[i + 1][j][k] = currentValue;
                        backtrack[i + 1][j][k] = {k, 'A'};
                    }
                }

                if (j < m) {
                    if (dp[i][j + 1][k] < currentValue) {
                        dp[i][j + 1][k] = currentValue;
                        backtrack[i][j + 1][k] = {k, 'B'};
                    }
                }

                if (i < n && j < m && a[i] == b[j]) {
                    int nextState = transition[k][(unsigned char)a[i]];
                    if (nextState < f && dp[i + 1][j + 1][nextState] < currentValue + 1) {
                        dp[i + 1][j + 1][nextState] = currentValue + 1;
                        backtrack[i + 1][j + 1][nextState] = {k, 'M'};
                    }
                }
            }
        }
    }

    int maxLength = 0, finalState = 0;
    for (int k = 0; k < f; k++) {
        if (dp[n][m][k] > maxLength) {
            maxLength = dp[n][m][k];
            finalState = k;
        }
    }

    string result;
    int i = n, j = m, k = finalState;
    while (i > 0 || j > 0) {
        auto [prevState, action] = backtrack[i][j][k];
        if (action == 'M') {
            result += a[i - 1];
            i--;
            j--;
        } else if (action == 'A') {
            i--;
        } else if (action == 'B') {
            j--;
        } else {
            break;
        }
        k = prevState;
    }

    reverse(result.begin(), result.end());
    return result;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string a,b,c;
    cin >>a>>b>> c;

    string lcs=findLCSExcluding(a, b, c);
    if(lcs.size()!=0)
    cout <<lcs;
    else
    cout<<'0';

}
